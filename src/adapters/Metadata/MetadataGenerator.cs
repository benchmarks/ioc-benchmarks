using Microsoft.CodeAnalysis;
using System.Reflection;
using System.Text;
using System.Xml;

namespace IoC.Adapter.Metadata
{
    [Generator]
    public class MetadataGenerator : ISourceGenerator
    {
        #region Constants

        const string _none = "None";
        const string _prefix =
            """
            // <auto-generated/>
            using System;

            namespace IoC.Adapter
            {
                public abstract partial class AdapterBase
                {
                    static public partial IEnumerable<AdapterInfo> GetAdapters()
                    {
            """;

        const string _suffix =
            """
                    }
                }
            }
            """;

        #endregion


        public void Execute(GeneratorExecutionContext context)
        {
            if (!context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.projectdir", out var projectDirectory))
                throw new InvalidOperationException("Source directory information is unavailable");

            var sb = new StringBuilder(_prefix);
            var exclude1 = Assembly.GetExecutingAssembly().GetName().Name;
            var exclude2 = context.Compilation.AssemblyName;
            string sourceDirectory = Path.GetFullPath(Path.Combine(projectDirectory, "..\\"));                

            foreach (var project in Directory.EnumerateFiles(sourceDirectory, "*.csproj", SearchOption.AllDirectories))
            {
                var name = Path.GetFileNameWithoutExtension(project);
                if (name == exclude1 || name == exclude2) continue;

                var dom = new XmlDocument();
                dom.Load(project);

                string package = _none;
                string version = _none;
                var node = dom.DocumentElement
                              .SelectNodes("//Project/ItemGroup/PackageReference")
                              .Cast<XmlNode>()
                              .Where(node => node.Attributes["Label"]?.InnerText == "container")
                              .FirstOrDefault();

                if (node is not null) 
                { 
                    package = node.Attributes["Include"].Value;
                    version = node.Attributes["Version"].Value;
                }

                var framework = dom.DocumentElement.SelectSingleNode("//Project/PropertyGroup/TargetFramework").InnerText;
                var url = dom.DocumentElement.SelectSingleNode("//Project/PropertyGroup/PackageProjectUrl")?.InnerText ?? _none;
                string id = dom.DocumentElement.SelectSingleNode("//Project/PropertyGroup/PackageId")?.InnerText ?? _none;
                string description = dom.DocumentElement.SelectSingleNode("//Project/PropertyGroup/Description")?.InnerText ?? _none;
                var info =
                    $$"""

                                yield return new AdapterInfo
                                {
                                    TargetFramework = "{{framework}}",
                                    Description     = "{{description}}",
                                    PackageName     = "{{package}}",
                                    PackageId       = "{{id}}",
                                    Version         = "{{version}}",
                                    Url             = "{{url}}",                                                    
                                    Name            = "{{name}}"
                                };

                    """;
                sb.AppendLine(info);
            }

            sb.AppendLine(_suffix);

            // Add the source code to the compilation
            context.AddSource($"AdapterBase.g.cs", sb.ToString());
        }


        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required for this one
        }
    }
}
